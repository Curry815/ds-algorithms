<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>封装集合</title>
  </head>
  <body>
    <script>
      function Set() {
        // 属性
        this.items = {};

        // 方法
        // add方法
        Set.prototype.add = function (value) {
          // 判断当前集合中是否已经包含了该元素
          if (this.has(value)) return false;

          this.items[value] = value;
          return true;
        };

        // has方法
        Set.prototype.has = function (value) {
          return this.items.hasOwnProperty(value);
        };

        //remove方法
        Set.prototype.remove = function (value) {
          // 判断当前集合中是否已经包含了该元素
          if (!this.has(value)) return false;

          // 删除元素
          delete this.items[value];
          return true;
        };

        // clear方法
        Set.prototype.clear = function () {
          this.items = {};
        };

        // size方法
        Set.prototype.size = function () {
          return Object.keys(this.items).length;
        };

        //values方法
        Set.prototype.valueKeys = function () {
          return Object.keys(this.items);
        };

        // 集合间的操作
        // 并集
        Set.prototype.union = function (otherSet) {
          // this: 集合对象A
          // otherSet: 集合对象B
          // 1.创建一个新的集合
          var unionSet = new Set();

          // 2.将A集合中的所有元素添加到这个新集合中
          var values = this.valueKeys();
          for (let i = 0; i < values.length; i++) {
            unionSet.add(values[i]);
          }

          // 3.将B集合中的所有元素添加到这个新集合中
          values = otherSet.valueKeys();
          for (let i = 0; i < values.length; i++) {
            unionSet.add(values[i]);
          }

          return unionSet;
        };

        //交集
        Set.prototype.intersection = function (otherSet) {
          // this: 集合对象A
          // otherSet: 集合对象B
          // 1.创建一个新的集合
          var intersectionSet = new Set();

          // 2.从A中取出一个个元素，判断是否同时存在于集合B中，存在放入新集合中
          var values = this.valueKeys();
          for (let i = 0; i < values.length; i++) {
            var item = values[i];
            if (otherSet.has(item)) {
              intersectionSet.add(item);
            }
          }

          return intersectionSet;
        };

        //差集
        Set.prototype.difference = function (otherSet) {
          // this: 集合对象A
          // otherSet: 集合对象B
          // 1.创建一个新的集合
          var differenceSet = new Set();

          // 2.从A中取出一个个元素，判断是否同时存在于集合B中，不存在放入新集合中
          var values = this.valueKeys();
          for (let i = 0; i < values.length; i++) {
            var item = values[i];
            if (!otherSet.has(item)) {
              differenceSet.add(item);
            }
          }

          return differenceSet;
        };

        //子集
        Set.prototype.subset = function (otherSet) {
          // this: 集合对象A
          // otherSet: 集合对象B
          // 1.遍历A中的所有元素，判断是否同时存在于集合B中
          var values = this.valueKeys();
          for (let i = 0; i < values.length; i++) {
            var item = values[i];
            if (!otherSet.has(item)) {
              return false;
            }
          }

          return true;
        };
      }

      // 测试
      // var set = new Set();
      // alert(set.add("abc"));
      // alert(set.add("abc"));
      // alert(set.add("cba"));
      // alert(set.add("mba"));
      // alert(set.valueKeys());
      // alert(set.remove("abc"));
      // alert(set.remove("abc"));

      var setA = new Set();
      setA.add("abc");
      setA.add("cba");
      setA.add("nba");

      var setB = new Set();
      setB.add("nba");
      setB.add("mba");
      setB.add("cba");

      // var unionSet = setA.union(setB);
      // alert(unionSet.valueKeys());

      // var intersectionSet = setA.intersection(setB);
      // alert(intersectionSet.valueKeys());

      // var differenceSet = setA.difference(setB);
      // alert(differenceSet.valueKeys());

      alert(setA.subset(setB));
    </script>
  </body>
</html>
